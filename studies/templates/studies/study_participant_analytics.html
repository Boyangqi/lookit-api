{% extends 'exp/base.html' %}
{% load bootstrap3 %}
{% load guardian_tags %}

{% block head %}
    {{ block.super }}
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" integrity="sha256-KM512VNnjElC30ehFwehXjx1YCHPiQkOPmqnrWtpccM=" crossorigin="anonymous"></script>

    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/bootstrap-select@1.13.10/dist/css/bootstrap-select.min.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap-select@1.13.10/dist/js/bootstrap-select.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.12.0/d3.min.js" integrity="sha256-+9Mf3cAVmxxudDsr1XwXUeRZFtvdWVYdq5/vcgiYyNU=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/metrics-graphics/2.15.6/metricsgraphics.min.css" integrity="sha256-H83YjkVzXEyHSdZ/5aVRoW2QfqeJ7gIWduA7aCy9tWY=" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/metrics-graphics/2.15.6/metricsgraphics.min.js" integrity="sha256-QFwUntQpro6H+h/btQ+8nVVDqeZnVQSuqsTTUGz2o44=" crossorigin="anonymous"></script>
    <!-- Moment -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/momentjs/latest/moment.min.js"></script>

    {# PivotTable.js #}
    <script src="https://cdn.jsdelivr.net/npm/pivottable@2.23.0/dist/pivot.min.js" integrity="sha256-/btBGbvOvx2h/NcXVS+JPFhnoUGbZXDX0O2v6AaABLU=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.23.0/pivot.min.css" integrity="sha256-nn3M6N8S2BjPirPhvCF61ZCcgcppdLtnaNOLhiwro7E=" crossorigin="anonymous" />

    {# Google Charts (for PivotTable js rendering) #}
    <script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pivottable/2.23.0/gchart_renderers.min.js" integrity="sha256-Ve5qXDsBeNuaKKg22jpTMlWThC0OWupW9JtFrXxdy1Q=" crossorigin="anonymous"></script>

    <!-- Datepicker -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/daterangepicker/daterangepicker.css"/>

    {% comment %}
        When we upgrade to django 2.x, please convert to the following insertions to json_script.
        Please see: https://docs.djangoproject.com/en/2.1/ref/templates/builtins/#json-script
    {% endcomment %}
    <script type="application/json" id="response-pivot-data">
        {{ response_pivot_data | safe }}
    </script>
    <script type="application/json" id="cumulative-timeseries-data">
        {{ cumulative_timeseries_data | safe }}
    </script>
    <script type="application/json" id="daily-timeseries-data">
        {{ daily_timeseries_data | safe }}
    </script>
    <script type="application/json" id="registration-data">
        {{ registration_data | safe }}
    </script>
    {{ form.media }}
{% endblock %}

{% block title %}Participant Analytics{% endblock %}

{% block flash %}
    {% if messages %}
        {% for message in messages %}
            <div id="details" class="alert {{ message.tags }} alert-dismissable">
                <a href="#" class="close" data-dismiss="alert" aria-label="close">&times;</a>
                {{ message }}
            </div>
        {% endfor %}
    {% endif %}
{% endblock %}

{% block content %}

    <div class="container">
        <nav class='row'>
            <section class="col-xs-12">
                <ol class="breadcrumb">
                    <li><a href="{% url 'exp:study-list' %}">Manage Studies</a></li>
                    <li class="active">Participant Analytics</li>
                </ol>
            </section>
        </nav>
        <section id="participation-section" class="row">
            <h3>Participation</h3>
            <article class="col-xs-4">
                <div id="participant-plot-filter-panel" class="panel panel-default">
                    <div class="panel-heading">
                        <h4>Plotting Options</h4>
                    </div>
                    <div class="panel-body">
                        <label class="control-label" for="date-filter">Date Range</label>
                        <input id="date-filter" class="form-control input-sm" type="text"/>
                        <label class="control-label" for="timeseries-filter">Counted Series</label>
                        <select id="timeseries-filter"
                                class="selectpicker form-control"
                                multiple>
                            <optgroup id="all-studies-filter" label="ALL STUDIES">
                                <option value="ALL:any"
                                        data-ruling="any">
                                    All Rulings
                                </option>
                                <option value="ALL:pending"
                                        data-ruling="pending">
                                    Pending
                                </option>
                                <option value="ALL:accepted"
                                        data-ruling="accepted">
                                    Accepted</option>
                                <option value="ALL:rejected"
                                        data-ruling="rejected">
                                    Rejected
                                </option>
                            </optgroup>
                            {% for study in all_studies %}
                                <optgroup label="{{ study.name }}"
                                          data-study-id="{{ study.id }}">
                                    <option value="{{ study.id }}:any"
                                            data-subtext="{{ study.name }}"
                                            data-ruling="any">
                                        All Rulings
                                    </option>
                                    <option value="{{ study.id }}:pending"
                                            data-subtext="{{ study.name }}"
                                            data-ruling="pending">
                                        Pending
                                    </option>
                                    <option value="{{ study.id }}:accepted"
                                            data-subtext="{{ study.name }}"
                                            data-ruling="accepted">
                                        Accepted
                                    </option>
                                    <option value="{{ study.id }}:rejected"
                                            data-subtext="{{ study.name }}"
                                            data-ruling="rejected">
                                        Rejected
                                    </option>
                                </optgroup>
                            {% endfor %}
                        </select>
                    <h5>Legend</h5>
                        <section id="plot-legend" class="small"></section>
                    </div>
                </div>
            </article>
            <section class="col-xs-8">
                <article id="binned-participation-plot"></article>
                <article id="cumulative-participation-plot"></article>
            </section>
        </section>
        <section id="registration-section" class="row">
            <h3>Registrations</h3>
            <article id="binned-registration-plot"></article>
            <article id="cumulative-registration-plot"></article>
        </section>
        <section id="summary-section" class="row">
            <h3>Summary Statistics</h3>
            <h4>Pivot Presets</h4>
            <div id="pivot-presets" class="btn-group btn-group" role="group" aria-label="Preset Pivot Choices">
                <button type="button"
                        class="btn btn-default"
                        data-cols="Parent/Guardian Age"
                        data-aggregator="Total # Responses"
                        data-renderer="Table"># Responses by Parent Age</button>
                <button type="button"
                        class="btn btn-default"
                        data-cols="Study"
                        data-rows="Consent Ruling"
                        data-aggregator="Total # Responses"
                        data-renderer="Stacked Bar Chart">Rulings by Study</button>
                <button type="button"
                        class="btn btn-default"
                        data-cols="Child Gender"
                        data-rows="Study"
                        data-aggregator="Unique Children"
                        data-renderer="Table">Unique Children per Study by Gender</button>
                <button type="button"
                        class="btn btn-default"
                        data-cols="Parent/Guardian Education Level"
                        data-aggregator="Unique Families"
                        data-renderer="Bar Chart">Unique Families per Parent/Guardian Education Level</button>
            </div>
            <h4>Pivot Table</h4>
            <article id="responses-pivot" class="col-md-12"></article>
        </section>
        <section>
            <h3>Multi-Value Field Breakdowns</h3>
            <article id="characteristics-table" class="col-md-4">
                <h4>Characteristics</h4>
                <table class="table small">
                    <thead>
                    <tr>
                        <th>Characteristic</th>
                        <th># Children</th>
                    </tr>
                    </thead>
                    <tbody>
                    {% for characteristic, child_count in characteristics.items %}
                        <tr>
                            <td>{{ characteristic }}</td>
                            <td>{{ child_count }}</td>
                        </tr>
                    {% endfor %}
                    </tbody>
                </table>
            </article>
            <article id="languages-table" class="col-md-4">
                <h4>Languages</h4>
                <table class="table small">
                    <thead>
                    <tr>
                        <th>Language</th>
                        <th># Children</th>
                    </tr>
                    </thead>
                    <tbody>
                    {% for language, child_count in languages.items %}
                        <tr>
                            <td>{{ language }}</td>
                            <td>{{ child_count }}</td>
                        </tr>
                    {% endfor %}
                    </tbody>
                </table>
            </article>
            <article id="studies-table" class="col-md-4">
                <h4>Studies</h4>
                <table class="table small">
                    <thead>
                    <tr>
                        <th>Study</th>
                        <th># Children</th>
                    </tr>
                    </thead>
                    <tbody>
                    {% for study_name, child_count in studies.items %}
                        <tr>
                            <td>{{ study_name }}</td>
                            <td>{{ child_count }}</td>
                        </tr>
                    {% endfor %}
                    </tbody>
                </table>
            </article>
        </section>

    </div>
    {# Load all the graphs now that vega has been loaded #}
    <script type="text/javascript">
        /* ------------------------- *
         * ---- ELEMENT HANDLES ---- *
         * ------------------------- */
        const $responsePivotElement = $("#responses-pivot"),
              $timeseriesFilter     = $("#timeseries-filter"),
              $dateFilter           = $('#date-filter'),
              $timeseriesOptions    = $timeseriesFilter.find("option");

        /* ------------------------- *
         * ---- DATA CONTAINERS ---- *
         * ------------------------- */
        const RESPONSE_PIVOT_DATA        = JSON.parse(document.querySelector("#response-pivot-data").innerText),
              CUMULATIVE_TIMESERIES_DATA = JSON.parse(document.querySelector("#cumulative-timeseries-data").innerText),
              DAILY_TIMESERIES_DATA      = JSON.parse(document.querySelector("#daily-timeseries-data").innerText),
              RAW_REGISTRATION_DATA      = JSON.parse(document.querySelector("#registration-data").innerText);

        // Need to actually have Date objects for PivotTable and MetricsGraphics to work.
        CUMULATIVE_TIMESERIES_DATA.forEach(record => record['date_of_response'] = new Date(record["date_of_response"]));
        DAILY_TIMESERIES_DATA.forEach(record => record['date_of_response'] = new Date(record["date_of_response"]));

        const CUMULATIVE_TIMESERIES_CACHE = {},
              BINNED_TIMESERIES_CACHE     = {},
              LEGEND_LABEL_CACHE          = {};

        /* ----------------------- *
         * ---- PLOT SETTINGS ---- *
         * ----------------------- */
        const DATE_FILTER_SETTINGS = {
            ranges: {
                'Today': [moment().startOf('day'), moment()],
                'Yesterday': [moment().subtract(1, 'day').startOf('day'), moment().subtract(1, 'days').endOf('day')],
                'Last 7 Days': [moment().subtract(6, 'days'), moment()],
                'Last 30 Days': [moment().subtract(29, 'days'), moment()],
                'Last Year': [moment().subtract(1, 'year'), moment()],
                'This Month': [moment().startOf('month'), moment().endOf('month')],
                'Last Month': [moment().subtract(1, 'month').startOf('month'), moment().subtract(1, 'month').endOf('month')],
            },
            startDate: moment().subtract(1, 'year'),
            endDate: moment(),
        };

        const BASE_SELECT_SETTINGS = {
            width: '100%',
            sanitize: true,
            liveSearch: true,
        };

        const TIMESERIES_FILTER_SETTINGS = $.extend(
            BASE_SELECT_SETTINGS,
            {
                selectedTextFormat: 'count',
                title: 'Select Timeseries to Display',
                liveSearchPlaceholder: 'Search by study name',
            }
        );

        // Boot up plots with defaults.
        const CUMULATIVE_PARTICIPATION_PLOT = {
            title: "Cumulative Participation",
            description: "Plots cumulative participation data.",
            data: null,  // Initialize in view init
            top: 70,
            full_width: true,
            height: 200,
            right: 40,
            interpolate: d3.curveStepAfter,
            target: document.getElementById('cumulative-participation-plot'),
            x_accessor: 'date_of_response',
            y_accessor: ['total_cumulative_responses'],
            y_label: "Cumulative Responses",
            legend: ["Total Cumulative Responses"],
            legend_target: "#plot-legend",
            area: false,  // Area doesn't work with multiple lines :(
        };

        const BINNED_PARTICIPATION_PLOT = {
            title: "Binned Participation",
            description: "Plots participation data by day/week/month granularities",
            data: null,  // Initialize in view init
            chart_type: "histogram",
            binned: true,
            top: 70,
            full_width: true,
            height: 300,
            right: 40,
            y_label: "Daily Responses",
            // missing_is_hidden: true,
            target: document.getElementById('binned-participation-plot'),
        };

        const CUMULATIVE_REGISTRATION_PLOT = {
            title: "Cumulative Registration",
            description: "Plots cumulative registration data.",
            data: null,  // Initialize in view init
            top: 70,
            full_width: true,
            height: 300,
            interpolate: d3.curveStepAfter,
            target: document.getElementById('cumulative-registration-plot'),
            y_label: "Cumulative Registrations",
            brush: "x",
            area: true,
        };

        const BINNED_REGISTRATION_PLOT = {
            title: "Binned Registration",
            description: "Plots daily registrations.",
            data: null,  // Initialize in view init
            chart_type: "histogram",
            binned: true,
            top: 70,
            full_width: true,
            height: 300,
            y_label: "Daily Registrations",
            // missing_is_hidden: true,
            target: document.getElementById('binned-registration-plot'),
        };

        const GLOBAL_PARTICIPATION_QUERY_STATE = {
            after: DATE_FILTER_SETTINGS.startDate,
            before: DATE_FILTER_SETTINGS.endDate,
            timeseriesHandles: ["ALL:any"],
            ruling: "any",
            studyId: null,
            studyName: null,
            legendLabels: ["Total Cumulative Responses"],
        };


        /* --------------------- *
         * ---- PIVOT TABLE ---- *
         * --------------------- */
        const pivotTableDerivers = $.pivotUtilities.derivers;
        const pivotAggregatorTemplates = $.pivotUtilities.aggregatorTemplates;
        const pivotTableRenderers = $.extend(
            {},
            $.pivotUtilities.renderers,
            $.pivotUtilities.gchart_renderers
        );
        const RESPONSE_PIVOT_OPTS = {
            cols: ["Study"],
            rows: ["Child Gender", "Child Gestational Age at Birth"],
            renderers: pivotTableRenderers,
            rendererName: "Table",
            aggregatorName: "Total # Responses",
            derivedAttributes: {
                "Date of Response": pivotTableDerivers.dateFormat("Time of Response", "%y/%m/%d")
            },
            aggregators: {
                "Unique Children": () => pivotAggregatorTemplates.countUnique()(["Child (unique identifier)"]),
                "Unique Families": () => pivotAggregatorTemplates.countUnique()(["Family (unique identifier)"]),
                "Total # Responses": () => pivotAggregatorTemplates.count()(),
                // TODO: This average will probably multiple-count children - we only want to include ages and
                //       incomes per child/family for a more accurate read. A custom aggregator is needed.
                "Average Child Age (days)": () => pivotAggregatorTemplates.average()(["Child Age in Days"]),
                "Average Child Age (months)": () => pivotAggregatorTemplates.average()(["Child Age in Months"]),
                "Average Child Age (years)": () => pivotAggregatorTemplates.average()(["Child Age in Years"]),
                "Average Annual Income": () => pivotAggregatorTemplates.average()(["Family Annual Income"]),
            },
            hiddenFromDragDrop: ["Time of Response", "Child (unique identifier)", "Family (unique identifier)"],
            rendererOptions: {
                gchart: {
                    width: 800,
                    height: 600,
                    interpolateNulls: true,
                    isStacked: false,
                }
            }
        };


        /* ---------------------- *
         * ---- VIEW METHODS ---- *
         * ---------------------- */
        function initializeView() {
            google.load("visualization", "1", {packages:["corechart", "charteditor"]});

            $responsePivotElement
                .pivotUI(
                    RESPONSE_PIVOT_DATA,
                    RESPONSE_PIVOT_OPTS
                );

            $dateFilter.daterangepicker(DATE_FILTER_SETTINGS, handleDateFiltering);

            regenerateRegistrationPlots();
            regenerateParticipationPlots();

            $timeseriesFilter
                .selectpicker(TIMESERIES_FILTER_SETTINGS)
                .on('changed.bs.select', handleTimeSeriesFilter);

            document.getElementById("pivot-presets").addEventListener("click", reloadPivot);
        }

        function regenerateRegistrationPlots() {
            [cumulativeSeries, binnedSeries] = generateRegistrationTimeseries(RAW_REGISTRATION_DATA);

            MG.data_graphic(
                $.extend(
                    BINNED_REGISTRATION_PLOT,
                    {
                        data: binnedSeries,
                    }
                )
            );

            MG.data_graphic(
                $.extend(
                    CUMULATIVE_REGISTRATION_PLOT,
                    {
                        data: cumulativeSeries,
                    }
                )
            );
        }

        /**
         * It's already in just plain old dates, we just need to create two series (cumulative and daily).
         *
         * XXX: This is a very rough and un-DRY implementation that should be refactored at a later point.
         * Namely, we're doing timeseries processing three different ways with three different data sets.
         * It makes sense to consolidate when we get user feedback and can hone in on an appropriate
         * data-processing strategy.
         */
        function generateRegistrationTimeseries(registrationData) {
            let binningOffset = (24 * 3600000); // eventually replace with some function

            return registrationData.reduce(
                ([cumulativeSeries, binnedSeries], timestamp) => {
                    // Round down for binning.
                    let observedDate = moment(timestamp).startOf("day").toDate();

                    let previousCumulativeObservation = cumulativeSeries.slice(-1)[0];

                    if (!previousCumulativeObservation) {  // First observation.
                        cumulativeSeries.push({
                            date: observedDate,
                            value: 1
                        });
                    } else {
                        cumulativeSeries.push({
                            date: observedDate,
                            value: previousCumulativeObservation.value + 1
                        });
                    }

                    let previousBinnedObservation = binnedSeries.slice(-1)[0];

                    if (previousBinnedObservation) {
                        if (sameDay(observedDate, previousBinnedObservation.date)) {
                            // Same day, so just add.
                            previousBinnedObservation.value += 1;
                        } else { // because it's sorted, we must be before, so create a bunch of same-value dummies
                            // Backpropagation similar to how we do with response timeseries data.
                            while (!sameDay(previousBinnedObservation.date, observedDate)) {
                                binnedSeries.push({
                                    date: new Date(previousBinnedObservation.date.getTime() + binningOffset),
                                    value: 0
                                });
                                previousBinnedObservation = binnedSeries.slice(-1)[0];
                            }
                            binnedSeries.push({
                                date: observedDate,
                                value: 1,
                            });
                        }
                    } else {
                        binnedSeries.push({
                            date: observedDate,
                            value: 1,
                        });
                    }

                    return [cumulativeSeries, binnedSeries];
                },
                [[],[]]
            );
        }


        /**
         * Datepicker event handling function.
         */
        function handleDateFiltering(after, before) {
            $.extend(GLOBAL_PARTICIPATION_QUERY_STATE, {after, before});
            regenerateParticipationPlots();
        }

        /**
         * On selection, tries to see if the TS has already been generated.
         *
         * @param $jqEvent
         * @param clickedIndex
         * @param isSelected
         * @param previousValue
         */
        function handleTimeSeriesFilter($jqEvent, clickedIndex, isSelected, previousValue) {

            let selectedRuling   = $timeseriesOptions[clickedIndex],
                optGroupForStudy = selectedRuling.parentNode;

            $.extend(
                GLOBAL_PARTICIPATION_QUERY_STATE,
                {
                    timeseriesHandles: $(this).val() || [],
                    ruling: selectedRuling.dataset.ruling,
                    studyName: optGroupForStudy.label,
                    studyId: optGroupForStudy.dataset.studyId,
                    legendLabels: []
                }
            );

            regenerateParticipationPlots();
        }

        /**
         * The workhorse of the participation plots - generates both plots based on filters.
         *
         * Because we want to enable orthogonal date filtering and series selection/composition,
         * we need to rely on some sort state that is modified by the component event listeners -
         * that is the GLOBAL_QUERY_STATE object referenced below. The procedural nature of this
         * function and reliance on module-wide state, while hard to test, is fairly easy to
         * understand and debug for such a small number of knobs to tweak.
         */
        function regenerateParticipationPlots() {
            let {
                after,
                before,
                timeseriesHandles,
                ruling,
                studyId,
                studyName,
                legendLabels,
            } = GLOBAL_PARTICIPATION_QUERY_STATE;

            // Set of linear series.
            let cumulativeSet = getCumulativeTimeseriesSet(
                timeseriesHandles, ruling, studyId, studyName, legendLabels, after, before
            );

            // Singular histogram series.
            let binnedSeries = getBinnedTimeseries(timeseriesHandles, after, before);

            drawTimeseriesPlots(cumulativeSet, binnedSeries, legendLabels);
        }


        function getBinnedTimeseries(timeseriesHandles, start, end) {
            let handle           = timeseriesHandles.sort().join('-'),
                binnedSeries     = BINNED_TIMESERIES_CACHE[handle];

            if (!binnedSeries) {
                let idRulingPairs = timeseriesHandles.map(handle => handle.split(":"));
                binnedSeries = BINNED_TIMESERIES_CACHE[handle] =
                   generateBinnedTimeSeries(idRulingPairs, start, end);
            }

            binnedSeries = binnedSeries.filter(
                observation => start.isBefore(observation["date"]) && end.isAfter(observation["date"])
            );

            return binnedSeries;
        }


        /**
         * Creates a list of lists, each inner list containing the datapoints for a cumulative time series.
         *
         * The data format of each observation is in the {data: xxxxxx, value: xxxxx} format that
         * MetricsGraphics.js expects.
         *
         * @param timeseriesHandles
         * @param ruling
         * @param studyId
         * @param studyName
         * @param legendLabels
         * @param start
         * @param end
         * @returns {*}
         */
        function getCumulativeTimeseriesSet(timeseriesHandles, ruling, studyId, studyName, legendLabels, start, end) {
            return timeseriesHandles.reduce(
                (cumulativeSet, handle) => {
                    let cumulativeSeries = CUMULATIVE_TIMESERIES_CACHE[handle],
                        legendLabel      = LEGEND_LABEL_CACHE[handle];
                    if (!legendLabel) {
                        legendLabel = LEGEND_LABEL_CACHE[handle] = `${studyName} - ${ruling}`;
                    }
                    if (!cumulativeSeries) {
                        cumulativeSeries = CUMULATIVE_TIMESERIES_CACHE[handle] =
                            generateCumulativeTimeSeries(
                                studyId,
                                ruling,
                                start,
                                end,
                            );
                    }

                    // Now filter based on date.
                    cumulativeSeries = cumulativeSeries.filter(
                        observation => start.isBefore(observation["date"]) && end.isAfter(observation["date"])
                    );

                    cumulativeSet.push(cumulativeSeries);
                    // true if it's an "any ruling" for that study
                    legendLabels.push(legendLabel);
                    return cumulativeSet;
                },
                [] // timeseriesSet initializer
            );
        }


        function drawTimeseriesPlots(cumulativeSet, binnedSeries, legendLabels) {
            // Now fill with data, y_accessor, and legend, then draw.
            let newPlotOptions = {
                x_accessor: "date",
                y_accessor: "value",
            };


            let cumulativePlotOpts = $.extend(
                {},
                CUMULATIVE_PARTICIPATION_PLOT,
                newPlotOptions,
                {
                    data: cumulativeSet,
                    legend: legendLabels,
                    chart_type: cumulativeSet.length && cumulativeSet[0].length ? "line" : "missing-data"
                }
            );

            // Don't understand what this does, but apparently have to do it:
            // https://metricsgraphicsjs.org/examples.htm#updating
            delete cumulativePlotOpts.xax_format;

            let binnedPlotOpts = $.extend(
                {},
                BINNED_PARTICIPATION_PLOT,
                newPlotOptions,
                {
                    data: binnedSeries,
                    chart_type: binnedSeries.length ? "histogram" : "missing-data"
                }
            );

            delete binnedPlotOpts.xax_format;

            MG.data_graphic(cumulativePlotOpts);
            MG.data_graphic(binnedPlotOpts);
        }

        function generateCumulativeTimeSeries(studyId, consentRuling) {
            // Determine aggregation field to pick.
            let aggField = getCumulativeAggregationField(studyId, consentRuling);
            return CUMULATIVE_TIMESERIES_DATA.reduce(
                (newSeries, responseDataPoint, currentIndex, sourceArray) => {
                    if ((consentRuling === "any" || responseDataPoint["current_ruling"] === consentRuling)    &&
                        (!studyId                || responseDataPoint["study__id"] === parseInt(studyId))) {
                        newSeries.push({
                            date: responseDataPoint["date_of_response"],
                            value: responseDataPoint[aggField]
                        });
                    } else {
                        // For continuity, we're adding a fake datapoint to the timeseries that is just the
                        // same as whatever the last value was. This will only work for cumulative datasets!
                        let previousPoint    = newSeries.slice(-1)[0],
                            newValue         = previousPoint ? previousPoint["value"] : 0;

                        newSeries.push({
                            date: responseDataPoint["date_of_response"],
                            value: newValue
                        });
                    }
                    return newSeries;
                },
                []  // newSeries initializer
            );
        }

        function getCumulativeAggregationField(studyId, consentRuling) {
            let aggField;
            if (studyId) {
                if (consentRuling === "any") {
                    aggField = "cumulative_count_per_study";
                } else {
                    aggField = "cumulative_count_per_study_by_ruling";
                }
            } else {
                if (consentRuling === "any") {
                    aggField = "total_cumulative_responses";
                } else {
                    aggField = "cumulative_count_per_ruling";
                }
            }
            return aggField;
        }

        function generateBinnedTimeSeries(idRulingPairs, interval="daily") {
            return DAILY_TIMESERIES_DATA.reduce(
                (newSeries, responseDataPoint) => {

                    // Make sure we match criteria for at least one of the pairs.
                    let dataPointIsValid = idRulingPairs.some(([studyId, consentRuling]) => {
                        return ((consentRuling === "any" || responseDataPoint["current_ruling"] === consentRuling)    &&
                                (studyId       === "ALL" || responseDataPoint["study__id"] === parseInt(studyId)))
                    });

                    if (dataPointIsValid) {
                        // If it matches the criteria, we add to the count.
                        let previousPoint = newSeries.slice(-1)[0];
                        if (responsesHappenedInSameBin(previousPoint, responseDataPoint)) {
                            previousPoint["value"] += responseDataPoint["num_responses"];
                        } else {
                            // First, backpropagate any missing days.
                            let binningOffset = (24 * 3600000); // eventually replace with some function

                            if (previousPoint) {
                                while (!responsesHappenedInSameBin(previousPoint, responseDataPoint)) {

                                    newSeries.push({
                                        date: new Date(previousPoint["date"].getTime() + binningOffset),
                                        value: 0
                                    });
                                    previousPoint = newSeries.slice(-1)[0];
                                }
                            }
                            newSeries.push({
                                date: responseDataPoint["date_of_response"],
                                value: responseDataPoint["num_responses"]
                            });
                        }
                    }
                    return newSeries;
                },
                []  // newSeries initializer.
            )
        }


        function responsesHappenedInSameBin(lastInSeries, currentResponse) {
            if (!lastInSeries || !currentResponse) return false;  // There's no first day to compare.
            let firstDate = lastInSeries["date"];
            let secondDate = currentResponse["date_of_response"];
            return sameDay(firstDate, secondDate);
        }

        function sameDay(firstDate, secondDate) {
            return firstDate && secondDate &&
                firstDate.getFullYear() === secondDate.getFullYear() &&
                firstDate.getMonth() === secondDate.getMonth() &&
                firstDate.getDate() === secondDate.getDate();
        }

        function reloadPivot(event) {
            let button;
            if ((button = event.target) && button.tagName === "BUTTON") {
                let data = button.dataset;
                RESPONSE_PIVOT_OPTS["cols"] = data.cols ? data.cols.split(", ") : [];
                RESPONSE_PIVOT_OPTS["rows"] = data.rows ? data.rows.split(", ") : [];
                RESPONSE_PIVOT_OPTS["aggregatorName"] = data.aggregator || "Total # Responses";
                RESPONSE_PIVOT_OPTS["rendererName"] = data.renderer || "Table";
                $responsePivotElement
                    .pivotUI(
                        RESPONSE_PIVOT_DATA,
                        RESPONSE_PIVOT_OPTS,
                        true
                    );
            }
        }

        /* ------------------------ *
         * ---- INITIALIZATION ---- *
         * ------------------------ */
        initializeView();
    </script>
{% endblock %}